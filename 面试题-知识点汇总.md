[TOC]

# jdk1.8以后的HashMap存储数据结构:链表长度超过8且数组长度大于64时,数据结构改为了红黑树 -> 涉及到查询高效率

HashMap的高效率

**HashMap是将key做hash算法，然后将hash值映射到内存地址，直接获取key所对应的数据**。

HashMap中数据存储的结构是数组+链表，**链表是为了解决hash碰撞问题**。

HashMap为什么快？主要是以下三点：

```
hash算法是高效的；
hash值到内存地址(数组索引)的算法是快速的；
根据内存地址(数组索引)可以直接获取对应的数据。
```

负载因子和阀值

负载因子又叫填充比，**是一个介于0和1之间的浮点数**，他决定了HashMap在扩容之前内部数组的填充度。**默认HashMap初始大小16，负载因子0.75**；

负载因子=元素个数/内部数组总数

在Jdk1.8以及以后的版本中,HashMap的底层数据结构由原来的数组+链表，调整为数组+链表/红黑树

首先明确链表的时间复杂度是O(n),红黑树时间复杂度是O(Logn)。**既然红黑树的复杂度优于链表，那么为为什么HashMap不直接使用红黑树代替链表呢？**

**树的节点占的空间是普通节点的两倍，在节点足够多的时候才会使用树形数据结构**，如果节点变少了还是会变回普通节点。总的来说就是节点太少的时候没必要转换、**不仅转换后的数据结构占空间而且转换也需要花费时间**。

**为了使hashCode分布良好,树形结构很少使用**。并且**在理想状态下受随机分布的hashCode影响**，链表中的节点遵循**泊松分布**，据统计**链表中的节点数是8的概率已经接近千分之一且此时链表的性能已经很差**。所以在这种比较罕见的和极端的情况下才会把链表转变为红黑树。

就是说大部分情况下HashMap还是使用链表，如果理想的均匀分布节点数不到8就已经自动扩容了。

## HashMap是将key做hash算法，然后将hash值映射到内存地址，直接获取key所对应的数据

## HashMap中数据存储的结构是数组+链表，**链表是为了解决hash碰撞问题**

## HashMap为什么快？-》 hash算法是高效的，hash值到内存地址(数组索引)的算法是快速的，根据内存地址(数组索引)可以直接获取对应的数据

## 默认HashMap初始大小16，负载因子0.75（负载因子=元素个数/内部数组总数）

## 在Jdk1.8以及以后的版本中,HashMap的底层数据结构由原来的数组+链表，调整为数组+链表/红黑树

## 既然红黑树的复杂度优于链表，那么为为什么HashMap不直接使用红黑树代替链表呢？

### 树的节点占的空间是普通节点的两倍，不仅转换后的数据结构占空间而且转换也需要花费时间

### 在理想状态下受随机分布的hashCode影响，链表中的节点遵循**泊松分布**，据统计**链表中的节点数是8的概率已经接近千分之一且此时链表的性能已经很差**

### 大部分情况下HashMap还是使用链表，如果理想的均匀分布节点数不到8就已经自动扩容了。


# hashMap、 hashTable、 和 ConcurrentHashMap的区别

## hashMap是线程不安全的，hashTable是线程安全的(用Synchronized)
## hashMap同hashTable；都是使用数组 + 链表结构
## ConcurrentHashMap : <JDK1.7>ConcurrentHashMap（分段锁;多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率）;
## ConcurrentHashMap:<jdk1.8>使用的是优化的synchronized和cas
## ConcurrentHashMap  <jdk1.7> ：使用 Segment数组 + HashEntry数组 + 链表
## ConcurrentHashMap  <jdk1.8> ：使用 Node数组+链表+ 红黑树
## 《1.7》ConcurrentHashMap 使用的分段锁，如果一个线程占用一段，别的线程可以操作别的部分，
## 《1.8》简化结构，put和get不用二次哈希，一把锁只锁住一个链表或者一棵树，并发效率更加提升

    主要区别：
    （1）：实现线程安全的方式
    hashMap是线程不安全的，
    hashTable是线程安全的，实现线程安全的机制是使用Synchronized关键字修饰方法。
    ConcurrentHashMap
    <JDK1.7>，
    ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。
    <jdk1.8>
    使用的是优化的synchronized 关键字 和 cas操作了维护并发。
    （2）：底层数据结构：
    hashMap同hashTable；都是使用数组 + 链表结构
    ConcurrentHashMap
    <jdk1.7> ：使用 Segment数组 + HashEntry数组 + 链表
    <jdk1.8> ：使用 Node数组+链表+ 红黑树
    （3） ： 效率
    hashMap只能单线程操作，效率低下
    hashTable使用的是synchronized方法锁，若一个线程抢夺了锁，其他线程只能等到持锁线程操作完成之后才能抢锁操作
    《1.7》ConcurrentHashMap 使用的分段锁，如果一个线程占用一段，别的线程可以操作别的部分，
    《1.8》简化结构，put和get不用二次哈希，一把锁只锁住一个链表或者一棵树，并发效率更加提升。


# 线程、进程、纤程的区别

![01_02](45EA31928C2B4B78B21497084190DA30)

## 面试高频：进程和线程有什么区别？-》分配资源，执行调度

    答案：进程就是一个程序运行起来的状态，线程是一个进程中的不同的执行路径。
    专业：进程是OS分配资源的基本单位，线程是执行调度的基本单位。
    分配资源最重要的是：独立的内存空间，线程调度执行
    （线程共享进程的内存空间，没有自己独立的内存空间）

## 面试题：线程和纤程的区别：-》用户态内核态切换、占用资源

    纤程(协程)：用户态的线程，线程中的线程，切换和调度不需要经过OS
    
    优势：1：占有资源很少 OS : 线程1M Fiber：4K 2：切换比较简单 3：启动数量多，启动很多个10W+
    
    目前2020 3 22支持内置纤程的语言：Kotlin Scala Go Python(lib)... Java? （open jdk : loom）
    
    线程的切换发生在内核空间，切换比较重,触发系统调用（80中断，callback）
    
    Java中对于纤程的支持：没有内置，利用Quaser库
    
    纤程的运行，需要设置javaagent:（讲object的内存大小的时候，提到了agent代理）


## - 线程的运行状态 runnable(ready、running)、waiting、blocked、timewaiting、teminated
![01_03](C837CBDBCF6042D0A75057776B0EBE36)
 
## - 线程的三种创建方式 -> thread/runnable/callable

    Thread  Runnable  Callable
    
    extends Thread -> run
    
    implements Runnable ->run
    
    implements Callable ->call
    new Thread(new FutureTask<String>(new Callable()))
    

## - 线程的5种启动方式

        Thread.start
        Thread(lambda表达式)
        new Thread(new Runnable()).start
        new Thread(new Future<String>(new Callable())).start
        Exectors.createCacheThreadPool().execute()  记得shutdown
  
## - 三个线程T1,T2,T3,怎么保证三个线程顺序执行  -> T1中调用T2.join(),T2中调用T3.join()
    
    答案：在主方法中，分别调用T1.join()/T2.join()/T3.join()  
    更精确的实现：T1中调用T2.join(),T2中调用T3.join()  

## - 同步和非同步方法是否可以同时调用? -> 可以

## - 模拟银行账户，对业务写方法加锁，对业务读方法不加锁，这样行不行？
 
        如果业务逻辑允许加锁，则不加锁；加锁以后，性能影响100倍
        如果业务逻辑不允许，会产生脏读（dirty read ），这时则不允许

# - 为什么Synchronized是可重入的? -》如果不可以会发生死锁
    
## - synchronized的底层实现

    JVM并没有对synchronized的实现做具体的规范  
    我这里说的Hotspot的实现，对象头记录所信息  

    1. 字节码层面
       方法层面：ACC_SYNCHRONIZED 0x0020
       同步语句块：monitorenter monitorexit
    
    2. JVM层面
       C C++ 调用了操作系统提供的同步机制
       
    3. OS和硬件层面
       X86 : lock cmpxchg / xxx


## - 锁升级过程

![微信截图_20200305210313](50216B4C8A154E6CBF8B10DC4978EF2F)

    Hotspot的实现：  
    
    1.new（无锁态）  
    2.只有一个线程 ：markword 记录这个线程ID （偏向锁） 
    3.如果线程争用：升级为 自旋锁(轻量级锁、无锁、自适应自旋锁)  
        使用CAS技术  
    4.自旋锁旋10次以后，升级为重量级锁 - OS   
    
    0 0 1：无锁态
    1 0 1：偏向锁
     0 0：轻量级锁、无锁、自旋锁、自适应自旋锁 -》使用CAS技术
     1 0：重量级锁
     1 1：GC标记

## 锁优化 -》 锁细化、锁粗化

    第一种方式：锁细化
        
    第二种方式：锁粗化
        应用于：竞争非常激烈的时候

## - 用户态和内核态的区别- 》自旋锁，是否占用cpu

    用户态：自旋锁  占用CPU
    很多服务需要用户态来帮助完成，比如启动、切换、关闭一个线程
    
    内核态：  
    线程放入操作系统的等待队列中，不占用CPU

## - 自旋锁和重量级锁的应用场景 -》 执行时间、线程数量

    应用场景：  
    自旋锁：执行时间短、线程数少  
    重量级锁：执行时间长、线程数多
    
    具体原因就是因为内核态和用户态

## synchronized异常情况下,会释放锁

## synchronized避免将锁定对象的引用变成另外的对象

## synchronized不要以字符串常量作为锁定对象

## - synchronized(Object)规定：不能用String常量、Integer、Long,为什么？ -》String(其他类库；锁重入/死锁) Integer/Long(一旦值改变，会产生一个新的对象)
 
    原因：String常量，导致其他使用String的类库，同一个线程会出现重入现象；如果不是同一个线程会发生死锁情况；  

    Integer，一旦值改变，会生产一个新的对象

```
public class DoNotLockString {
	
	String s1 = "Hello";
	String s2 = "Hello";

	void m1() {
		synchronized(s1) {
			try {
				System.out.println("m1 start");
				System.in.read();
			} catch (IOException e) {
				e.printStackTrace();
			}

			System.out.println("m1 end");
		}
	}
	
	void m2() {
		synchronized(s2) {
			try {
				System.out.println("m2 start");
				System.in.read();
			} catch (IOException e) {
				e.printStackTrace();
			}
			System.out.println("m2 end");
		}
	}

	public static void main(String[] args) {
		DoNotLockString object = new DoNotLockString();
		new Thread(()->object.m1(),"T1").start();
		new Thread(()->object.m2(),"T2").start();
	}

}

运行结果：
m1 start
```

# - 听说过单例模式吗？单例模式中有DCL模式听说过吗？那么DCL要不要加volatile?（美团) ->加 线程间可见、指令重排(主要)

    要加volatile  
    加的目标：线程间可见，主要是为了防止指令重排序
    
## volatile的底层实现

    1. 字节码层面
       ACC_VOLATILE  0x0040
       
    2. JVM层面
       volatile内存区的读写 都加屏障
       JVM的内存屏障是依赖CPU的内存屏障的
    
       StoreStoreBarrier
       volatile 写操作
       StoreLoadBarrier
    
       LoadLoadBarrier
       volatile 读操作
       LoadStoreBarrier
       
    3. OS和硬件层面
        windows lock 指令实现 | MESI实现    
    
        lock指令 xxx执行  xxx指令的时候保证对内存区域加锁
    
## 面试题：volatile能不能修饰引用类型的对象？为什么 -》对象中的属性地址对于其他线程不可见

    不能；因为因为对象中的某个属性发生改变，别的线程是不可见的
    也就是说volatile可见的是对象的引用地址，对象中的属性地址对于其他线程并不可见  
    
# CAS的原理

## incrementAndGet -> getAndAddInt -> compareAndSetInt（CAS）;cpu原语支持 -》lock指令

    AtomicXXX类使用了CAS技术（AtomicInteger/AtomicLong/AtomicDouble/AtomicBoolean）
    以AtomicInteger类(java.util.concurrent)为例，incrementAndGet()
    sun.misc.Unsafe类的getAndAddInt
    jdk.internal.misc.Unsafe的compareAndSetInt(CAS)  native方法
    
    compareAndSetInt(V,expected,newValue)
    
    cas((V,expected,newValue))
    if V=E
        V=new
        otherwise try again or fail
    
    cas是cpu原语支持，也就是说cas操作是cpu指令级别上的支撑，中间不能被打断
    
    C++代码
    os::is_mp()
    LOCK_IF_MP(mp)
    
    单处理器：cmpxchg
    多处理器：lock cmpxchg
    
    cmpxchg指令不能保证原子性
    lock指令保证了原子性

## ABA问题-》基本数据类型，引用类型

### ==加版本号,JDK中加boolean类型，AtomicStampedRefence== 
    
    线程1访问变量，这个变量有1变为2再变回1

    解决：1.加版本号
    2.JDK中加boolean类型：使用AtomicStampedReference(从Java1.5开始JDK的atomic包里提供)

    影响：
        如果是基本数据类型，无所谓

        如果是引用类型，会有问题
        从引用地址来看，引用对象O没有改变，但是引用对象O中的属性A，已经发生了改变
        举例：我和女朋友分手了，复合之前呢，女朋友其实已经又交往了另外几个男朋友

## synchronized保证了原子性，但是不能阻止重排序

## volatie不能保证原子性，所以不能替换synchronized

## 也就是说volatile并不能保证多个线程共同修改volatile变量时所带来的不一致问题 volatile修饰的变量，线程间是可见的，但是对于变量的修改不能保证原子性操作，所以不能替代synchronized


          
## 三种方式实现递增 -》 LongAddr》AtomicInteger》synchronized

    LongAddr(分段锁)---AtomicXXX(CAS)---synchronizde（重量级锁)
    性能跟线程数以及操作的执行次数有关
    
    LongAddr.increment()
    AtomicLong.incrementAndGet()
    synchronized ++
    
## LongAddr -》 分段锁 

### 线程数特别多的时候，有优势 ->将要执行的线程，分段放入不同的数组中，执行后再求和

    分段锁
    将要执行的线程，分段放入不同的数组中，执行后再求和
    线程数特别多的时候，有优势
    
# ==================================

# 各种同步锁：都是基于AQS来实现的

## ReentrantLock 可重入锁 面试重点
    
## 区别：ReentrantLock VS synchronized 

### CAS/重量级锁  是否需要手动加锁解锁；tryLock(time)、lockInterruptidly、公平锁和非公锁的切换：==不同的condition即不同的等待队列==

### Condition produceCondition=new ReentrantLock().newCondition(); produceCondition.await();produceCondition.notifyAll();

    ReentrantLock需要手动加锁、解锁
        底层：采用CAS技术
        不同的Condition即不同的等待队列
        支持tryLock、lockInterruptidly、公平锁和非公平锁的切换
        
    Synchronized：
        底层是锁升级
        自动加锁、解锁
    
    补充：=-=-=-=-=-=-=
    大部分的同步都是采用CAS技术
    但是AQS内部用的park和unpark，也不是全部用的cas，他还做了一个锁升级的概念，只不过这个锁升级做的比较隐秘
    
    trylock，
        使用tryLock进行尝试锁定，不管锁定与否，方法都将继续执行；synchronized如果搞不定的话肯定就阻塞了
        
        可以根据tryLock的返回值来判定是否锁定
        
        也可以指定tryLock的时间，由于tryLock(time)抛出异常，所以要注意unclock的处理，必须放到finally中
    lockInterruptibly
        使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应，可以被打断的加锁
    
    公平锁和非公平锁的切换 ：new ReentrantLock(true)
    
    private Lock lock = new ReentrantLock();
    private Condition produceCondition = lock.newCondition();
    private Condition customerCondition = lock.newCondition();
    lock.lock();lock.unlock();
    
    produceCondition.await();
    produceCondition.notifyAll();

```
//lock+Condition(await/signalAll)（乐观锁）

public class T02_LockAndCondition<T> {
    private LinkedList<T> list = new LinkedList<>();
    final private int MAX = 10;
    private int count =0;

    private Lock lock = new ReentrantLock();
    private Condition produceCondition = lock.newCondition();
    private Condition customerCondition = lock.newCondition();

    public T get(){
        T t =null;
        try {
            lock.lock();
            while (list.size()==0){
                customerCondition.await();
            }
            t= list.removeFirst();
            count--;
            produceCondition.signalAll();//通知生产者进行生产
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return t;
    }

    public void put(T t){
        try {
            lock.lock();
            while (list.size()==MAX){//想想为什么用while而不是用if？
                produceCondition.await();
            }
            list.add(t);
            count++;
            customerCondition.signalAll();//通知消费者线程进行消费
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        T02_LockAndCondition<String> object = new T02_LockAndCondition<>();
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                for (int j = 0; j < 5; j++) {
                    System.out.println(Thread.currentThread().getName()+" "+object.get());
                }
            },"customer "+i).start();
        }

        for (int i = 0; i < 2; i++) {
            new Thread(()->{
                for (int j = 0; j < 25; j++) {
                    object.put(Thread.currentThread().getName()+" "+j);
                }
            },"produce "+i).start();
        }
    }

}
```

## CountDownLatch（面试重灾区）

### 一般用于中台的程序 await()/countdown()

```
CountDownLatch latch = new CountDownLatch(5);
latch.await()
latch.countDown()
```

## CyclicBarrier循环栅栏

### 复杂操作：数据库、网络、文件 -> await()

    场景2：复杂操作
        数据库、网络、文件
        
        并发执行：
            不同线程执行不同的操作
            必须三个线程都执行完，才能继续执行，这时候使用CyclicBarrier

```
public class TestCyclicBarrier02{
    public void m(String name){
        System.out.println(name+" 任务执行");
    }

    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(3,()->{
            System.out.println("模拟结束");
        });

        TestCyclicBarrier02 t = new TestCyclicBarrier02();
        new Thread(()->{
            try {
                t.m("读数据库");
                barrier.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();

        new Thread(()->{
            try {
                t.m("读文件");
                barrier.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();

        new Thread(()->{
            try {
                t.m("读网络数据");
                barrier.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();
    }
}

运行结果：
读数据库 任务执行
读文件 任务执行
读网络数据 任务执行
模拟结束
```

```
public class TestCyclicBarrier {
    public static void main(String[] args) {
//        CyclicBarrier barrier = new CyclicBarrier(5);
        /*CyclicBarrier barrier = new CyclicBarrier(5, new Runnable() {
            @Override
            public void run() {
                System.out.println("人满，发车");
            }
        });*/
        CyclicBarrier barrier = new CyclicBarrier(5,()->{
            System.out.println("人满，发车");
        });

        for(int i=0;i<20;i++){
            new Thread(()->{
                try {
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}

运行结果：
人满，发车
人满，发车
人满，发车
人满，发车
```
## Phaser阶段，面试不多，加分项 

### 新郎新娘结婚 -> 需要分多个阶段执行的，并且需要多个线程一起协调调用 -》 一个阶段(异步)，多个阶段(同步) 

### 继承Phaser,重写onAdvance() -> arriveAndAwaitAdvance(),arriveAndDeregister() 

    结合了CyclicBarrier和CountDownLatch

    先异步后同步
        一个阶段：先异步
        多个阶段：同步
    
    场景：需要分多个阶段执行的，并且需要多个线程一起协调配合

```
public class TestPhaser {
    static MarriagePhaser phaser = new MarriagePhaser();

    static void millisSleep(int millis){
        try {
            TimeUnit.MILLISECONDS.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        phaser.bulkRegister(7);
        for(int i=0;i<5;i++){
            new Person("p"+i).start();
        }
        new Person("新郎").start();
        new Person("新娘").start();
    }

    static class MarriagePhaser extends Phaser{
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            switch (phase){
                case 0:
                    System.out.println("所有人到齐了！人数为："+registeredParties);
                    System.out.println();
                    return false;
                case 1:
                    System.out.println("所有人吃完了！人数为："+registeredParties);
                    System.out.println();
                    return false;
                case 2:
                    System.out.println("所有人离开了！人数为："+registeredParties);
                    System.out.println();
                    return false;
                case 3:
                    System.out.println("婚礼结束，新郎新娘抱抱！人数为："+registeredParties);
                    System.out.println();
                    return true;
                default:
                    return true;

            }
        }
    }

    static class Person extends Thread{
        private String name;
        public Person(String name){
            this.name = name;
        }
        public void arrive(){
            millisSleep(1000);
            System.out.printf("%s 到达现场!\n",name);
            phaser.arriveAndAwaitAdvance();
        }

        public void eat(){
            millisSleep(1000);
            System.out.printf("%s 吃完！\n",name);
            phaser.arriveAndAwaitAdvance();
        }

        public void leave(){
            millisSleep(1000);
            System.out.printf("%s 离开！\n",name);
            phaser.arriveAndAwaitAdvance();
        }

        public void hug(){
            if(name.equals("新郎") || name.equals("新娘")){
                millisSleep(1000);
                System.out.printf("%s 拥抱！\n",name);
                phaser.arriveAndAwaitAdvance();
            }else{
                phaser.arriveAndDeregister();
            }
        }

        @Override
        public void run() {
            arrive();
            eat();
            leave();
            hug();
        }
    }
}

运行结果：
p2 到达现场!
p1 到达现场!
新娘 到达现场!
p0 到达现场!
p4 到达现场!
新郎 到达现场!
p3 到达现场!
所有人到齐了！人数为：7

p3 吃完！
p4 吃完！
p1 吃完！
新娘 吃完！
p0 吃完！
新郎 吃完！
p2 吃完！
所有人吃完了！人数为：7

p4 离开！
p2 离开！
p3 离开！
p0 离开！
新娘 离开！
p1 离开！
新郎 离开！
所有人离开了！人数为：7

新娘 拥抱！
新郎 拥抱！
婚礼结束，新郎新娘抱抱！人数为：2
```

## - ReadWriteLock(面试会经常问到) 

### - 读写锁、共享锁、排他锁(互斥锁) 

### ReadWriteLock readWriteLock = new ReentrantReadWriteLock()；Lock readLock=readeWriteLock.readLock()/writeLock(); -> lock.lock()/unlock()

    读写锁
        共享锁
        排它锁（互斥锁）

```
public class TestReadWriteLock {
    public static Lock lock = new ReentrantLock();

    public static ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    public static Lock readLock = readWriteLock.readLock();
    public static Lock writeLock = readWriteLock.writeLock();

    private static int count =0;

    public static void read(Lock lock){
        try {
            lock.lock();
            TimeUnit.MILLISECONDS.sleep(1000);
            System.out.println("read over");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public static void write(Lock lock,int value){
        try {
            lock.lock();
            count = value;
            TimeUnit.MILLISECONDS.sleep(1000);
            System.out.println("write over");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        TestReadWriteLock t = new TestReadWriteLock();

        Runnable read = ()->read(lock);
        Runnable write = ()->write(lock,new Random().nextInt());

//        Runnable read = ()->read(readLock);
//        Runnable write = ()->write(writeLock,new Random().nextInt());

        for (int i = 0; i < 18; i++) {
            new Thread(read).start();
        }

        for (int i = 0; i < 2; i++) {
            new Thread(write).start();
        }
    }
}

运行结果：lock
read over!  一秒执行一句
read over!  一秒执行一句
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
write over!  一秒执行一句
write over!  一秒执行一句

运行结果：readLock writeLock
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
read over!
            同时运行read
write over!  一秒执行一句
write over!  一秒执行一句

```

## Semaphore信号灯 

### 限流 -》可以设置为公平锁new Semaphore(2,true) -》acquire/release 获得锁，不是获得线程

    信号灯

    可以设置为公平锁：
        new Semaphore(size,true);
    
    方法：acquire() 获得锁，不是获得线程
          release() 释放锁
    
    应用：限流
        售票，只能有5个人可以买票
        分批发短信
        类似：收费站，8辆车，2个收费站
        
    acquire是获得锁，而不是获得线程
    
    ThreadPool 线程池可以同时获取几个线程，不涉及同步的概念
    而Semaphore是用于线程同步的

```
public class TestSemaphore {

    public static void main(String[] args) {
        //允许一个线程同时执行
        //Semaphore s = new Semaphore(1);
        Semaphore s  = new Semaphore(2,true);

        new Thread(()->{
            try {
                s.acquire();
                System.out.println("T1..running");
                Thread.sleep(500);
                System.out.println("T1---end");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                s.release();
            }

        }).start();

        new Thread(()->{
            try {
                s.acquire();
                System.out.println("T2..running");
                Thread.sleep(500);
                System.out.println("T2---end");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                s.release();
            }
        }).start();
    }
}

运行结果：1
T1..running
T1---end
T2..running
T2---end

运行结果：2
T1..running
T2..running
T1---end
T2---end
```


## Exchanger 

### 两个线程之间交互数据 游戏中两个人交换装备，游戏中进行交易 -> 注意：只适用于两个线程 

### 线程1.执行到exchange()时，将值写入到容器中，然后线程阻塞 线程2执行到exchange()时，也将值写入到容器中，这是线程1和线程2的值进行交换，然后线程1,2继续执行

面试不会问到，用于扩展知识面

Exchanger<String> exchanger = new Exchanger<>();
方法：exchange()

Exchanger就是一个容器
应用于：两个线程之间交互数据
    游戏中两个人交换装备，游戏中进行交易

注意：只适用于两个线程

线程1.执行到exchange()时，将值写入到容器中，然后线程阻塞
线程2执行到exchange()时，也将值写入到容器中，这是线程1和线程2的值进行交换，然后线程1,2继续执行

取消：初始化的时候设置timeout参数Exchanger

```
public class TestExchanger {
    static Exchanger<String> exchanger = new Exchanger<>();

    public static void main(String[] args) {

        new Thread(()->{
            String s = "t1";
            try {
                s =  exchanger.exchange(s);
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+" "+s);
        },"T1").start();

        new Thread(()->{
            String s = "t2";
            try {
                s =  exchanger.exchange(s);
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+" "+s);
        },"T2").start();
    }
}

运行结果：
T2 t1
T1 t2
```

# LockSupport 

## 使当前线程阻塞，或唤醒 LockSupport.park()，LockSupport.unpark(thread) -> 源码UNSAFE.park()

## unpark可以先与park调用，这样设置park的时候就不会进入阻塞状态

## park()方法两次，还会进入阻塞状态

## notify(thread),并且不一定能唤醒指定的线程（等待队列中的线程）

    JDK1.X(自己查)支持了LockSupport
    
    作用：使当前线程阻塞，或唤醒
        之前使线程阻塞，需要对一个对象加锁，然后wait();唤醒用：notify(),并且不一定能唤醒指定的线程（等待队列中的线程）
        
    Locksupport.park();是线程阻塞
    
    LockSupport.unpark(thread);线程继续运行
   
    unpark可以先与park调用，这样设置park的时候就不会进入阻塞状态
    
    park()方法两次，还会进入阻塞状态
    
    park方法的源码（Unsafe类）
    
```
public static void park() {
    UNSAFE.park(false, 0L);
}
```


```
public class TestLockSupport {
    public static void main(String[] args) {
        Thread t= new Thread(()->{
            for (int i = 0; i < 10; i++) {
                System.out.println(i +"======="+System.currentTimeMillis());
                if(i == 5) {
                    LockSupport.park();
                }
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        t.start();
//        LockSupport.unpark(t); //unpark 先于park前调用，i==5,则不会进入阻塞状态

        try {
            TimeUnit.SECONDS.sleep(8);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        LockSupport.unpark(t);
    }
}

运行结果：
0=======1583930658587
1=======1583930659588
2=======1583930660589
3=======1583930661589
4=======1583930662590
5=======1583930663590 阻塞3秒
6=======1583930667588
7=======1583930668588
8=======1583930669589
9=======1583930670589

```

# 推荐书籍:并发编程的艺术(适合深入研究)  实战java高并发编程设计(适合入门)

# 淘宝面试题：线程间通信

    实现一个容器，提供两个方法：add,size
    写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束：
    
    add、size---用linkedList
        
    volatile修饰引用类型变量的时候，引用对象的属性发生改变，其他线程不可以减
    
    当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了
    这时应该考虑countdownlatch/cyclicbarrier/semaphore
    
## 推荐实现一：volatile +synchronized+wait+notify两次（悲观锁）

```
//volatile +synchronized+wait+notify两次
public class T04_waitAndNotify {
    /*volatile*/ List<Object> list = new LinkedList<>();

    public void add(Object o){
        list.add(o);
    }

    public int size(){
        return list.size();
    }

    public static void main(String[] args) {
        T04_waitAndNotify o = new T04_waitAndNotify();

        final Object lock = new Object();

        new Thread(()->{
            synchronized (lock){
                System.out.println("T2 start");
                if(o.size() !=5){
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("T2...end");
                //通知t1继续执行
                lock.notify();
            }
        }).start();

        new Thread(()->{
            System.out.println("T1 start");
            synchronized (lock){
                for (int i = 0; i < 10; i++) {
                    o.add(new Object());
                    System.out.println("add  "+i);
                    if(o.size()==5){
                        //释放锁，让T2执行
                        lock.notify();
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    /*try {
                        TimeUnit.SECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }*/
                }
            }
        },"T1").start();

    }
}

运行结果：
T2 start
T1 start
add  0
add  1
add  2
add  3
add  4
T2...end
add  5
add  6
add  7
add  8
add  9
```

## 推荐实现二：LockSupport两次，可以不用volatile修饰list对象（乐观锁）t2先启动

```
//LockSupport两次，这是可以不用volatile修饰list对象（乐观锁）
public class T08_lockSupport {
    static Thread t1=null, t2 =null;

    List<Object> list = new LinkedList<>();

    public void add(Object o){
        list.add(o);
    }

    public int size(){
        return list.size();
    }

    public static void main(String[] args) {
        T08_lockSupport o = new T08_lockSupport();

        t1 = new Thread(()->{
            System.out.println("T1 start");
            for (int i = 0; i < 10; i++) {
                o.add(new Object());
                System.out.println("add  "+i);
                if(o.size()==5){
                    LockSupport.unpark(t2);
                    LockSupport.park();
                }
                /*try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }*/
            }
        },"T1");

        t2 = new Thread(()->{
            System.out.println("T2 start");
            /*if(o.size() !=5){
                LockSupport.park();
            }*/
            LockSupport.park();
            System.out.println("T2...end");
            LockSupport.unpark(t1);
        });

        t2.start();
        t1.start();
    }
}

运行结果：
T2 start
T1 start
add  0
add  1
add  2
add  3
add  4
T2...end
add  5
add  6
add  7
add  8
add  9
```
## 实现三：Semaphore 执行完前5次，t2.start,t2.join()  再执行后面的5次
```
public class T09_Semaphore {
    static Thread t1=null, t2 =null;

    volatile List<Object> list = new LinkedList<>();

    public void add(Object o){
        list.add(o);
    }

    public int size(){
        return list.size();
    }

    public static void main(String[] args) {
        T09_Semaphore o = new T09_Semaphore();

        Semaphore s = new Semaphore(1);

        t1 = new Thread(()->{
            System.out.println("T1 start");
            try {
                s.acquire();
                for (int i = 0; i < 5; i++) {
                    o.add(new Object());
                    System.out.println("add  "+i);
                }
                s.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            try {
                t2.start();
                t2.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            try {
                s.acquire();
                for (int i = 5; i < 10; i++) {
                    o.add(new Object());
                    System.out.println("add  "+i);
                }
                s.release();
            } catch (Exception e) {
                e.printStackTrace();
            }

        },"T1");

        t2 = new Thread(()->{
            try {
                System.out.println("T2 start");
                s.acquire();
                System.out.println("T2...end");
                s.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        t1.start();
    }
}

运行结果：
T1 start
add  0
add  1
add  2
add  3
add  4
T2 start
T2...end
add  5
add  6
add  7
add  8
add  9
```

# 淘宝面试题：生产者消费者

写一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用
    
    
    固定容器--LinkedList--final int MAX=10
        
    实现一：synchronized+wait+notifyAll两次（悲观锁）
        while的判断，线程被唤醒以后，还需要再次判断是否满足条件
        有个弊端：notifyAll不仅会唤醒消费者线程，也会唤醒生产者线程
    
    推荐实现二：lock+Condition(await/signalAll)（乐观锁）
        condition能精确的唤醒某些线程
        
    本质：
    synchronized，wait是一个等待队列
    condition是不同的等待队列，customer和producer两个等待队列

## 实现一：synchronized+wait+notifyAll两次（悲观锁）
```
//synchronized+wait+notifyAll两次（悲观锁）

public class T01_WaitNotifyAll<T> {
    private LinkedList<T> list = new LinkedList<>();
    final private int MAX =10;
    private int count =0;

    public synchronized T get(){
        T t =null;
        while (list.size()==0){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        t= list.removeFirst();
        count--;
        this.notifyAll();//通知生产者进行生产
        return t;
    }
    
    /**想想为什么用while而不是用if？
        当线程被叫醒，还需要再次判断
        如果不判断直接执行，现在MAX=10,应该是不行执行，但是使用了if程序就会继续执行，size>10
    **/
    public synchronized void put(T t){
        while (list.size()==MAX){//想想为什么用while而不是用if？
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        list.add(t);
        count++;
        this.notifyAll();//通知消费者线程进行消费
    }

    public static void main(String[] args) {
        T01_WaitNotifyAll<String> object = new T01_WaitNotifyAll<>();

        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                for (int j = 0; j < 5; j++) {
                    String t = object.get();
                    System.out.println(Thread.currentThread().getName()+" "+t);
                }
            },"customer "+i).start();
        }

        for (int i = 0; i < 2; i++) {
            new Thread(()->{
                for (int j = 0; j < 25; j++) {
                    object.put(Thread.currentThread().getName()+" "+j);
                }
            },"produce "+i).start();
        }
    }
}
```

## 推荐实现二：lock+Condition(await/signalAll)（乐观锁）
```
//lock+Condition(await/signalAll)（乐观锁）

public class T02_LockAndCondition<T> {
    private LinkedList<T> list = new LinkedList<>();
    final private int MAX = 10;
    private int count =0;

    private Lock lock = new ReentrantLock();
    private Condition produceCondition = lock.newCondition();
    private Condition customerCondition = lock.newCondition();

    public T get(){
        T t =null;
        try {
            lock.lock();
            while (list.size()==0){
                customerCondition.await();
            }
            t= list.removeFirst();
            count--;
            produceCondition.signalAll();//通知生产者进行生产
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return t;
    }

    public void put(T t){
        try {
            lock.lock();
            while (list.size()==MAX){//想想为什么用while而不是用if？
                produceCondition.await();
            }
            list.add(t);
            count++;
            customerCondition.signalAll();//通知消费者线程进行消费
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        T02_LockAndCondition<String> object = new T02_LockAndCondition<>();
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                for (int j = 0; j < 5; j++) {
                    System.out.println(Thread.currentThread().getName()+" "+object.get());
                }
            },"customer "+i).start();
        }

        for (int i = 0; i < 2; i++) {
            new Thread(()->{
                for (int j = 0; j < 25; j++) {
                    object.put(Thread.currentThread().getName()+" "+j);
                }
            },"produce "+i).start();
        }
    }

}
```
# =========================================

# AQS

    state: volatile int 
    Node(双向链表 static final class) 监控state的双向链表
        ASQ队列又叫CLH队列:互相抢夺的线程
        -Thread
        -Node pre
        -Node Next
           Node head
           Node tail
           Thread thread 线程；一个node得到了state这把锁，就说明这个node里的线程持有这把锁
           

    compareAndSetState(0, acquires))方法尝试把state的值改为1，加入改成了setExclusiveOwnerThread(current)把当前线程设置为肚胀state这把锁的状态

## AQS的核心：使用CAS操作tail节点
## - 说说AQS -> 效率很高，双向链表(线程队列)+volatile(state状态)+CAS(操作tail节点)
## - 为什么说AQS的底层是volatile+CAS？

    1.AQS中有state属性，是用volatile修饰的
    2.Node(双向链表)，head、next、pred、tail
        调用addWaiter()往队列里加节点的时候，使用了compareAndSetState方法，该方法就是CAS技术
        也就是说：使用CAS来操作tail节点,不需要锁定整个链表
    
## - 为什么AQS效率高？-》  cas操作tail节点,不需要锁定这个链表

    1.AQS中使用了双向链表
    2.往链表的尾端添加节点时候，使用CAS，不需要锁定整个链表,我只需要判断oldTail和链表当前的tail是否一致，如果一致，说明没有别的线程来操作,这样的情况下，AQS的效率更高
    3.Node中使用VarHandle；
    VarHandle(变量句柄)的特点：
        第一，完成普通属性的原子性操作；并且这个原子性操作还是线程安全的
        第二：比反射快，直接操作二进制码

## 调用addWaiter()往队列里加节点的时候，使用了compareAndSetState方法(CAS),使用CAS来操作tail节点,不需要锁定这个链表

## Node中使用Varhandle(变量句柄)[普通属性的原子性操作+原子性的线程安全操作+ 比反射快，直接操作二进制码]


# ThreadLocal

ThreadLocal线程局部变量

ThreadLocal是使用空间换时间，synchronized是使用时间换空间

==比如在hibernate中session就存在与ThreadLocal中，避免synchronized的使用==

    ThreadLocal<Person> tl = new ThreadLocal<>();
    System.out.println(tl.get());
    tl.set(new Person());

        
## 为什么ThreadLocal中用到了弱引用？ -> 防止内存泄漏，Thread类中有threadLocals属性,key是对ThreadLocal对象的引用,key采用弱引用，key就会被GC回收【key】

![501](6255F56B44FB4B5AA8FE04D76036A26F)

    防止内存泄漏，针对的是threadLocals中key的引用
    
    Thread类中有threadLocals属性（所属类是：ThreadLocal.ThreadLocalMap），key是对ThreadLocal对象的引用，当t1对象设置为null，使用了弱引用，key就会被GC回收
    
    
## 为什么ThreadLocal使用后要调用remove方法？  防止内存泄漏，针对的是threadLocals中value的引用【value】
    
    防止内存泄漏，针对的是threadLocals中value的引用

## 软引用 SoftReference -> 缓存,大图片、数据库读取大堆数据 -》内存不够用的时候，才会被回收

应用于缓存，Tomcat和memberCache就使用了软引用，将大图片或大量数据读到内存中；内存不够的时候才会被回收

    软引用是用来描述一些还有用但并非必须的对象。
        对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收。
        如果这次回收还没有足够的内存，才会抛出内存溢出异常。
        -Xms20M -Xmx20M
        
        应用：适合缓存使用
            读一个大图片放到内存中
            从数据库读一大堆的数据放到内存中
            
            tomcat和memberCache中用到了软引用
    
    ==内存不够用的时候，才会被回收==

## 弱引用 WeakReference（面试重点）-》 弱引用遇到GC就会被回收，一般用在容器里；ThreadLocal -》可以get到值

    弱引用遭到gc就会回收
    如果有一个强引用同时存在的话，当强引用消失的话，弱引用自动消失
    
    应用：一般用在容器里
        ThreadLocal
        
==弱引用遇到GC就会被回收   == 

## 虚引用：PhantomReference 应用程序用不到，写JVM或Netty要用到 -》永远get不到值 -》遇到GC时，发系统通知，通知知ReferenceQueue进行内存回收 -》用途：堆外内存的释放 -》 DirectByteBuffer通过虚引用来实现堆外内存的释放的 -》Unsafe类：直接内存的分配和回收【 allocateMemory、freeMemory】

    应用：管理堆外内存的
    
    为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知
    
    遇到GC时，发系统通知，通知知ReferenceQueue进行内存回收
    
    弱引用：可以get到值
    虚引用：永远get不到值
        get不到值有什么用呢？虚引用对象被干掉后，通知Queue
        
    DirectByteBuffer通过虚引用来实现堆外内存的释放的
    
    java里Unsafe类：直接内存的分配和回收
        allocateMemory()方法直接分配内存，也就是分配堆外内存
        freeMemory()方法回收内存也就是手动回收内存
        
        Unsafe类，JDK8可以通过反射使用；JDK9以后不能被使用
        
    
    
    一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，
    也无法通过虚引用来获取一个对象的实例。
    为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
    虚引用和弱引用对关联对象的回收都不会产生影响，如果只有虚引用活着弱引用关联着对象，
    那么这个对象就会被回收。它们的不同之处在于弱引用的get方法，虚引用的get方法始终返回null,
    弱引用可以使用ReferenceQueue,虚引用必须配合ReferenceQueue使用。
 
    jdk中直接内存的回收就用到虚引用，由于jvm自动内存管理的范围是堆内存，
    而直接内存是在堆内存之外（其实是内存映射文件，自行去理解虚拟内存空间的相关概念），
    所以直接内存的分配和回收都是有Unsafe类去操作，java在申请一块直接内存之后，
    会在堆内存分配一个对象保存这个堆外内存的引用，
    这个对象被垃圾收集器管理，一旦这个对象被回收，
    相应的用户线程会收到通知并对直接内存进行清理工作。
 
    事实上，虚引用有一个很重要的用途就是用来做堆外内存的释放，
    DirectByteBuffer就是通过虚引用来实现堆外内存的释放的。
 
    
## 虚引用与弱引用的区别
    
    GC
        虚引用：遇到GC，发系统通知，通知ReferenceQueue进行内存回收
        弱引用：遇到GC就会被回收
    
    get
        虚引用：get不到值
        弱应用：get到值
    
    应用：
        虚引用：堆外内存的管理，Unsafe类中直接内存的分配以及回收( freeMemory() )；
            DirectByteBuffer就是通过虚引用来实现对外内存的释放
        
        弱应用：ThreadLocal或者容器中，防止内存泄漏
        
## 谈一谈强软弱虚

    强：常见的引用，引用消失，GC时被回收
    软：应用于缓存，Tomcat和memberCache就使用了软引用，将大图片或大量数据读到内存中；内存不够的时候才会被回收
    弱：ThreadLocal，防止内存泄漏；遇到GC就会被回收
    虚：堆外内存的管理，get不到值，GC时通知ReferenceQueue进行内存回收；DirectByteBuffer就是通过虚引用对堆外内存进行释放
    
# synchronized能锁的最小对象是什么？-》synchronized锁的是对象头部markwork中的两个标识位

    synchronized锁的是对象头部markwork中的两个标识位
    
    0 0 1：无锁态
    1 0 1：偏向锁
      0 0：轻量级锁
      1 0：重量级锁
      1 1：GC标记
    
    最小对象这个问题，问的就有问题

# ===============================    
# 并发容器（面试重灾区）

![601](93B9C6E74B2642FBB75A2F6C7024D70E)

    并发容器涉及的内容：
        数据结构
        算法
        容器的组织结构
        高并发
        
    容器分两大类：
    -collection
        分三大类：
        -list
        -set
        -queue
            Deque:双端队列
            priorityQueue:优先队列
            DelayQueue:到期
    
    -map

## 面试题：既然已经有了list和set，为什么还要有queue(list、set、queue的区别)?-》队列是为了实现任务的装载的取和装，阻塞队列，为高并发准备的
    
    队列是为了实现任务的装载的取和装，阻塞队列，为高并发准备的
    list和set是为了普通的取/装

## 发展历程    

### HashTable->HashMap->SynchronizedHashMap ->ConcurrentHashMap

### Vector Hashtable ：早期使用synchronized实现

### ArrayList HashMap ：未考虑多线程安全（未实现同步）

### Hashmap vs Hashtable StringBuilder vs StringBuffer

### Collections.synchronized***工厂方法使用的也是synchronized

## 读写效率测试：HashTable(写效率高)--- HashMap( 写效率高)----Collections.SynchronizedMap(写效率高)--- ConcurrentHashMap(读的效率高，写的效率低)

### 并不是说ConcurrentHashMap就一定比HashMap好，要进行测试，才能知道效率谁更好

### 同理，CAS不一定就比Synchronized好，他们有各自的适应的场景

## 卖票(各容器的实现)

### synchronized -》 size和进行remove必须是一整个的原子操作、



```
public class T03_Synchronized {
    public static List<String> list = new LinkedList<>();

    static {
        for (int i = 0; i < 1000; i++) {
            list.add("车票编号："+i);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                synchronized (list){
                    while (list.size()>0){
                        try {
                            TimeUnit.MILLISECONDS.sleep(10);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println("销售了"+list.remove(0));
                    }
                }
            }).start();
        }
    }
}
```
### ConcurrentLinkedQueue -> 使用ConcurrentQueue提高并发性,打印前后顺序有问题，但是确实卖了1000张

```
public class T04_ConcurrentQueue {
    public static Queue<String> list = new ConcurrentLinkedQueue<>();

    static {
        for (int i = 0; i < 1000; i++) {
            list.add("车票编号："+i);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                while (list.size()>0){
                    try {
                        TimeUnit.MILLISECONDS.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("销售了"+list.poll());
                }
            }).start();
        }
    }
}

运行结果：

销售了车票编号：999
销售了车票编号：996
销售了车票编号：997
销售了车票编号：994
销售了车票编号：995
销售了车票编号：993
销售了车票编号：992
销售了车票编号：990
```

# 多线程情况下使用比较多的容器

### 排好顺序的Map:TreeMap、linkedhashMap、ConcurrentSkipListMap

### 没有排序的Map：HashMap、ConcurrentHashMap

## 没有ConcurrentTreeMap这个类 

### ConcurrentHashMap使用了CAS，CAS用在TreeMap上太复杂了；这时候为了有排序的map，这时就有了ConcurrentSkipListMap

## ConcurrentSkipListMap 

### 跳表结构 -》 关键元素的链表；分层；使用CAS相比TreeMap又比较容易

## 面试题：TreeMap一定要说明使用了红黑树

## CopyOnWriteArrayList 

### 写时复制 -》 ReadAndWriteLock -》 多线程环境下，写时效率低，读时效率高 -》适合写少读多的环境 -》 写的时候加锁，复制的时候，length+1 

    多线程环境下，写时效率低，读时效率高
    适合写少读多的环境
    
    适用于：写少，读多
        读不加锁，写加锁
        
    复制的时候，数组长度会加1
    
    写的时候加锁，复制的时候，length+1

## Queue提供的方法：offer(与add的区别：会返回一个值：是否添加成功)、poll(取，并且remove)、peek（取，但是不remove）
    
## ConcurrentLinkedQueue

## LinkedBlockingQueue 

```
public class TestConcurrentQueue {
    public static void main(String[] args) {
        Queue<String> queue = new ConcurrentLinkedQueue<>();
        for (int i = 0; i < 10; i++) {
            queue.offer("a"+i);
        }

        System.out.println(queue.size());

        String poll = queue.poll();
        System.out.println(poll);
        System.out.println(queue.size());

        String peek = queue.peek();
        System.out.println(peek);
        System.out.println(queue.size());

    }
}
```

### 实现了生产者、消费者的原型 -》 实现线程池的基础 -》 Blocking阻塞 -》 LinkedBlockingQueue不是无界队列，最大量为Integer的最大值

LinkedBlockingQueue不是无界队列，最大量为Integer的最大值 最小值是 -2,147,483,648（-2^31） 最大值是 2,147,483,647（2^31 - 1）

### 在Queue的基础上添加了put(一定要往进加，如果队列满了，会阻塞)、take（一定要外拿，如果队列为空，会阻塞）

#### 这两个方法体现了Blocking,实现阻塞的原理：Condition的await、signalAll

    
## ArrayBlockingQueue 

### 有界队列 -》 put(阻塞)，add(满了报异常，queue full) ，offer(用返回值来判断是否添加成功，不报异常，因为offer会返回是否添加成功),offer("",1,TimeUnit.Seconds)，设置阻塞的时间

## 面试题：Queue和list的区别(常考) 

### queue 添加了offer 、peek、poll、put、take这些个对线程友好的或者阻塞，或者等待的方法


## 阻塞的BlockingQueue ：DelayQueue、SynchronusQueue、TransferQueue

## DelayQueue

### 按紧迫程度进行排序，应用：按时间进行任务调度 -》本质是PriorityQueue


```
public class TestDelayQueue {
    static class MyTask implements Delayed {
        private String name;
        private long runningTime;

        public MyTask(String name, long runningTime) {
            this.name = name;
            this.runningTime = runningTime;
        }

        @Override
        public long getDelay(TimeUnit unit) {
            return unit.convert(runningTime-System.currentTimeMillis(),TimeUnit.MILLISECONDS);
        }

        @Override
        public int compareTo(Delayed o) {
            if(this.getDelay(TimeUnit.MILLISECONDS) < o.getDelay(TimeUnit.MILLISECONDS)){
                return -1;
            }else if(this.getDelay(TimeUnit.MILLISECONDS) > o.getDelay(TimeUnit.MILLISECONDS)){
                return 1;
            }else {
                return 0;
            }
        }

        @Override
        public String toString() {
            return name+"==="+runningTime;
        }
    }

    public static void main(String[] args) {
        BlockingQueue<MyTask> queue = new DelayQueue<>();
        long now = System.currentTimeMillis();
        MyTask task1 = new MyTask("t1",now+1000);
        MyTask task2 = new MyTask("t2",now+500);
        MyTask task3 = new MyTask("t3",now+1500);
        MyTask task4 = new MyTask("t4",now+2500);
        MyTask task5 = new MyTask("t5",now+2000);

        queue.add(task1);
        queue.add(task2);
        queue.add(task3);
        queue.add(task4);
        queue.add(task5);

        for (int i = 0; i < 5; i++) {
            try {
                System.out.println(queue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}

运行结果：
t2===1584261977532
t1===1584261978032
t3===1584261978532
t5===1584261979032
t4===1584261979532
```


## PriorityQueue

### 特点：不是按顺序添加，内部是有排序的 -》内部结构是二叉树、最小堆


```
public class TestPriorityQueue {
    public static void main(String[] args) {
        PriorityQueue<String> queue = new PriorityQueue<>();
        queue.add("e");
        queue.add("b");
        queue.add("a");
        queue.add("d");
        queue.add("c");

        int size  = queue.size();
        for (int i = 0; i < size; i++) {
            System.out.println(queue.poll());
        }
    }

}

运行结果：
a
b
c
d
e
```


## SynchronusQueue

### 同步Queue -》 容量为0，不是用来装内容，是一个线程给另一个线程下达命令 -》 take/put方法，线程阻塞 -》 add方法直接报异常：Queue full，因为容量为0 -》 对比Exchanger(交换数据)，SynchronusQueue更方便

```
public class SynchronusQueue {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<String> queue = new SynchronousQueue<>();

        new Thread(()->{
            try {
                queue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

//        queue.put("aaa");
//        queue.add("aaa");
        System.out.println(queue.size());
    }

}
```



## TransferQueue 

### 传递Queue -》transfer方法 -》传递内容(多人对多人的手递手) -> 交叉打印A1B2C3 -> 场景1：付账以后等付账的结果，给客户反馈 -> 场景2：面对面付款 -> MQ已经实现了

    传递Queue
        方法：transfer
            与put的区别：
                put是添加完就没事了
                transfer是添加完，等着，等有线程取走了，该方法才结束
        
        传递内容：
            多人对多人的手递手
            
        应用：
            场景1：付账以后等付账的结果，给客户反馈
            场景2：面对面付款
            
            场景3：交叉打印A1B2C3
            
            MQ已经实现了
            
            java实现的话，用TransferQueue

### transfer vs put -》put是添加完就没事了-》transfer是添加完，等着，等有线程取走了，该方法才结束

# 面试题：要求用两个线程交替打印：A1B2C3....Z26

## LockSupport（背会）-> 注意：sout的位置、以及park、unpaik的顺序

```
public class Test01_LockSupport {
    static Thread t1=null,t2 =null;

    public static void main(String[] args) {
        char[] numbers = {'1','2','3','4','5','6','7','8'};
        char[] letters ={'A','B','C','D','E','F','G','H'};

        t1 = new Thread(()->{
            for (int i = 0; i < numbers.length; i++) {
                System.out.print(numbers[i]);
                LockSupport.unpark(t2);
                LockSupport.park();
            }
        },"T1");

        t2 = new Thread(()->{
            for (int i = 0; i < letters.length; i++) {
                LockSupport.park();
                System.out.print(letters[i]);
                LockSupport.unpark(t1);
            }
        },"T2");

        t1.start();
        t2.start();
    }

}
```

##  wait+notify（背会，面试重灾区） -> 代码打印完，记得notify，否则程序无法结束

### sleep可以替代wait吗？不行，因为Sleep不释放锁

```
public class Test02_WaitNotify {
    public static void main(String[] args) {
        char[] numbers = {'1','2','3','4','5','6','7','8'};
        char[] letters ={'A','B','C','D','E','F','G','H'};
        Object o = new Object();

        new Thread(()->{
            synchronized (o){
                for(char c:numbers){
                    try {
                        System.out.print(c);
                        o.notify();
                        o.wait();//让出锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                o.notify();//必须，否则无法停止程序
            }
        }).start();

        new Thread(()->{
            synchronized (o){
                for(char c:letters){
                    try {
                        System.out.print(c);
                        o.notify();
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
                o.notify();
            }
        }).start();

    }
}
```

## wait+notify（背会，保证顺序）

    如果我想保证t2在t1之前打印，也就是说保证首先输出的是A而不是1，这个时候该如何做？

    方法一：countdownLatch
        注意：await、countdowm的位置
        
    方法二：boolean
        注意是while，而不是if
        volatile修饰
    
    join可行吗？
        不可行，因为需要等T2结束了，T1才执行，这样就达不到交替运行的效果


```
public class Test03_WaitNotify_Boolean {
    static volatile boolean t2First = true;

    public static void main(String[] args) {
        char[] numbers = {'1','2','3','4','5','6','7','8'};
        char[] letters ={'A','B','C','D','E','F','G','H'};
        Object o = new Object();

        new Thread(()->{
            synchronized (o){
                while(t2First){
                    try {
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                for(char c:numbers){
                    try {
                        System.out.print(c);
                        o.notify();
                        o.wait();//让出锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                o.notify();//必须，否则无法停止程序
            }
        },"T1").start();

        new Thread(()->{
            synchronized (o){
                for(char c:letters){
                    try {
                        System.out.print(c);
                        t2First=false;
                        o.notify();
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
                o.notify();
            }
        },"T2").start();

    }
}
```

```
public class Test03_WaitNotify_CountDownLatch {

    public static void main(String[] args) {
        char[] numbers = {'1','2','3','4','5','6','7','8'};
        char[] letters ={'A','B','C','D','E','F','G','H'};
        Object o = new Object();

        CountDownLatch latch = new CountDownLatch(1);

        new Thread(()->{
            try {
                latch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            synchronized (o){
                for(char c:numbers){
                    try {
                        System.out.print(c);
                        o.notify();
                        o.wait();//让出锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                o.notify();//必须，否则无法停止程序
            }
        },"T1").start();

        new Thread(()->{
            synchronized (o){
                for(char c:letters){
                    try {
                        System.out.print(c);
                        latch.countDown();
                        o.notify();
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
                o.notify();
            }
        },"T2").start();

    }
}
```

## 解法4：lock+condition ->类似于wait+notify

```
public class Test04_LockAndCondition {
    public static void main(String[] args) {
        char[] numbers = {'1','2','3','4','5','6','7','8'};
        char[] letters ={'A','B','C','D','E','F','G','H'};
        Lock lock = new ReentrantLock();
        Condition condition = lock.newCondition();

        new Thread(()->{
            try {
                lock.lock();
                for(char c:numbers){
                    System.out.print(c);
                    condition.signal();
                    condition.await();
                }
                condition.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        },"T1").start();

        new Thread(()->{
            try {
                lock.lock();

                for(char c:letters){
                    System.out.print(c);
                    condition.signal();
                    condition.await();
                }
                condition.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        },"T2").start();

    }

}
```
    
## 解法5：lock+condition(两个condition，推荐)
```
public class Test05_LockAndCondition {
    public static void main(String[] args) {
        char[] numbers = {'1','2','3','4','5','6','7','8'};
        char[] letters ={'A','B','C','D','E','F','G','H'};
        Lock lock = new ReentrantLock();
        Condition condition1 = lock.newCondition();
        Condition condition2 = lock.newCondition();

        new Thread(()->{
            try {
                lock.lock();
                for(char c:numbers){
                    System.out.print(c);
                    condition2.signal();
                    condition1.await();
                }
                condition2.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        },"T1").start();

        new Thread(()->{
            try {
                lock.lock();

                for(char c:letters){
                    System.out.print(c);
                    condition1.signal();
                    condition2.await();
                }
                condition1.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        },"T2").start();

    }

}
```

# =================================

# 线程池 -》 线程的定义和运行可以分开了

```
public class T04_ExecutorService {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService service = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 6; i++) {
            service.execute(()->{
                try {
                    TimeUnit.MILLISECONDS.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
            });
        }

        System.out.println(service);

        service.shutdown();

        //执行1
        /*System.out.println(service.isTerminated());
        System.out.println(service.isShutdown());*/

        //执行2
        TimeUnit.SECONDS.sleep(5);
        System.out.println(service.isTerminated());
        System.out.println(service.isShutdown());

        System.out.println(service);

    }
}

运行结果：执行1
java.util.concurrent.ThreadPoolExecutor@5e9f23b4[Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]
false
true
java.util.concurrent.ThreadPoolExecutor@5e9f23b4[Shutting down, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]
pool-1-thread-4
pool-1-thread-3
pool-1-thread-1
pool-1-thread-2
pool-1-thread-5
pool-1-thread-4

运行结果：执行2
java.util.concurrent.ThreadPoolExecutor@5e9f23b4[Running, pool size = 5, active threads = 5, queued tasks = 1, completed tasks = 0]
pool-1-thread-1
pool-1-thread-4
pool-1-thread-3
pool-1-thread-5
pool-1-thread-2
pool-1-thread-1
true
true
java.util.concurrent.ThreadPoolExecutor@5e9f23b4[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 6]

```

## ExecutorService -》 完善了任务执行器的生命周期

### submit(异步 提交任务)、shutdown结束、shutdownNow、isShutdown、awaitTermination(等着结束，等多长时间，时间到了还不结束的话他返回false)

    完善了任务执行器的生命周期
        shutdown//结束
        shutdownNow//马上结束
        isShutdown// 是不是整体都执行完了
        awaitTermination//等着结束，等多长时间，时间到了还不结束的话他返回false
        
        submit
            异步 提交任务
            涉及的类：
                -Future
                    -get() 阻塞的
                -Callable
                
### Callable -》call()有返回值 -》为线程池而设计的

    跟Runnable一样，可以让另外一个线程运行它
    区别：call()有返回值，Runnable没有返回值
        Callable=Runnable + result
    
    Callable为线程池而设计的
    用Future来存储Callable运行的结果

```
public class T01_Callable {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        /*Callable<String> call = new Callable<String>() {
            @Override
            public String call() throws Exception {
                return "callable";
            }
        };*/
        Callable<String> call = ()->{
            return "callable";
        };

        ExecutorService service = Executors.newCachedThreadPool();
        Future<String> future = service.submit(call);//异步
        String result = future.get();//阻塞
        System.out.println(result);

        service.shutdown();
    }
}
```

### Callable VS  Runnable 

#### call()有返回值，Runnable没有返回值 -> Callable=Runnable + result -> Callable为线程池而设计的 -> 用Future来存储Callable运行的结果

### Future ->存储将来执行的结果

### FutureTask 

#### FutureTask=Runnable + Future -> ForkJoinPool和WorkStealingPool会用到

    class FutureTask<V> implements RunnableFuture<V>
    interface RunnableFuture<V> extends Runnable, Future<V>
    
    FutureTask=Runnable + Future
    把Runnable运行的结果存储在自己中
    
    ForkJoinPool和WorkStealingPool会用到
    
### CompletableFuture(面试会问，但是实际开发可以研究)(很牛逼的类，加分项) 

#### 底层用ForkJoinPool -> 是各种任务的管理类 ->管理多个Future的结果 -> 对任务的组合

#### supplyAsync/allOf()/anyOf()

    底层用ForkJoinPool

    是各种任务的管理类
    
    管理多个Future的结果
    
    对任务的组合
    对任务的lambda的使用
    
    
    supplyAsync
    
    allOf()
    anyOf()
        论文查重，只要一个查到重复就可以
        
    ==读API的用法

#### 面试题：如何对多个Future进行管理 ->使用CompletableFuture

#### 面试题：假设你能够提供一个服务，这个服务查询各大电商网站同一类商品 价格并汇总展示

```
public class T03_CompletableFuture {
    public static void delay(){
        int time  = new Random().nextInt(500);
        try {
            TimeUnit.MILLISECONDS.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.printf("after %s sleep\n",time);
    }

    public static double priceOfTB(){
        delay();
        return 1.00;
    }

    public static double priceOfJD(){
        delay();
        return 2.00;
    }

    public static double priceOfPDD(){
        delay();
        return 2.50;
    }

    public static void main(String[] args) {
        long start,end;

        start = System.currentTimeMillis();

        CompletableFuture<Double> future_JD  = CompletableFuture.supplyAsync(()->priceOfJD());
        CompletableFuture<Double> future_TB  = CompletableFuture.supplyAsync(()->priceOfTB());
        CompletableFuture<Double> future_PDD  = CompletableFuture.supplyAsync(()->priceOfPDD());

        CompletableFuture.allOf(future_JD,future_TB,future_PDD).join();

        CompletableFuture.supplyAsync(()->priceOfJD())
                .thenApply(String::valueOf)
                .thenApply(str-> "price:"+str)
                .thenAccept(System.out::println);

        end = System.currentTimeMillis();

        System.out.println("complete future need time "+(end-start));

        try {
            System.in.read();//
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

运行结果：
after 167 sleep
after 254 sleep
after 258 sleep
complete future need time 263
after 18 sleep
price:2.0
```
    
## 线程池分两种类型：ThreadPoolExecutor + ForkJoinFool

### ThreadPoolExecutor ->一个线程的集合+ 一个任务的集合 -》 底层数据结构 ：  HashSet<Worker> workers = new HashSet<>() + BlockingQueue<Runnable> workQueue

    extends AbstractExecutorService

    阿里手册要求线程池自定义
    
    维护两个集合
        一个线程的集合
        一个任务的集合
        
        底层数据结构：
            HashSet<Worker> workers = new HashSet<>() 
            BlockingQueue<Runnable> workQueue

### 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯

### 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险

### Executors 返回的线程池对象的弊端如下：

#### 1） FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
#### 2） CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。
        

### 线程池定义的7个参数(背会)

    int corePoolSize  核心线程，
        核心线程即使最长空闲时间到了，并不归还给操作系统
    
    int maximumPoolSize 最大线程
    long keepAliveTime 最长空闲时间
        灭活
        
    TimeUnit unit 空闲时间的的单位
    
    BlockingQueue<Runnable> workQueue  任务队列
        ArrayBlockingQueue
        LinkedBlockingQueue
        SynchronusQueue   进来一个任务，处理一个任务
        TransferQueue 
        DelayQueue
    
    ThreadFactory threadFactory  线程工厂
        自己定义
            阿里手册规定：
            【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯
            
            【强制】 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
            说明： Executors 返回的线程池对象的弊端如下：
            1） FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
            2） CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。
            
        默认：Executors.defaultThreadFactory

#### RejectedExecutionHandler拒绝策略-Abort、Discard、DiscardOldest(游戏的位置信息，扔掉最老的位置信息)、CallerRun

```
class DefaultThreadFactory

public Thread newThread(Runnable r) {
    Thread t = new Thread(group, r,
                          namePrefix + threadNumber.getAndIncrement(),
                          0);//指定线程名称
    if (t.isDaemon())
        t.setDaemon(false);//设置为非守护线程
    if (t.getPriority() != Thread.NORM_PRIORITY)
        t.setPriority(Thread.NORM_PRIORITY);//设置优先级
    return t;
}
```

        RejectedExecutionHandler handler  拒绝策略
            new ThreadPoolExecutor.DiscardOldestPolicy()
            
            线程池忙，并且线程池队列满了，执行拒绝策略
            
            拒绝策略可自定义
                实际项目都是自定义
                保存到kafka、redis、MQ、数据库，并做好日志
                如果有大量的任务没有处理，说明该加机器了
                
            JDK默认提供了四种，实际项目中很少用到这4个
                -Abort：抛异常
                -Discard:扔掉，不抛异常
                -DiscardOldest:扔掉排队时间最久的
                    应用场景：游戏的位置信息，扔掉最老的位置信息
                -CallerRuns:调用者处理任务
 

```
public class T14_MyRejectedHandler {
    public static void main(String[] args) {
        ExecutorService service = new ThreadPoolExecutor(4, 4,
                0, TimeUnit.SECONDS, new ArrayBlockingQueue<>(6),
                Executors.defaultThreadFactory(),
                new MyHandler());
    }

    static class MyHandler implements RejectedExecutionHandler {

        @Override
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
            //log("r rejected")
            //save r kafka mysql redis
            //try 3 times
            if(executor.getQueue().size() < 10000) {
                //try put again();
            }
        }
    }
}
```
          
```
public class T05_ThreadPoolExecutor {

    static class Task implements Runnable{
        private int i;

        public Task(int i) {
            this.i = i;
        }

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName()+" task "+i);
            try {
                System.in.read();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        @Override
        public String toString() {
            return "Task{i=}"+i;
        }
    }

    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(2,4,
                60, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(4),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy()
                );

        for (int i = 0; i < 8; i++) {
            executor.execute(new Task(i));
        }

        System.out.println(executor.getQueue());

        executor.execute(new Task(100));
        System.out.println(executor.getQueue());

        executor.shutdown();
    }

}

运行结果：AbortPolicy
[Task{i=}2, Task{i=}3, Task{i=}4, Task{i=}5]
pool-1-thread-3 task 6
pool-1-thread-2 task 1
pool-1-thread-1 task 0
pool-1-thread-4 task 7
Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task Task{i=}100 rejected from java.util.concurrent.ThreadPoolExecutor@7c3df479[Running, pool size = 4, active threads = 4, queued tasks = 4, completed tasks = 0]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)
	at com.mashibing.mycode.threadPoolExecutor.T05_ThreadPoolExecutor.main(T05_ThreadPoolExecutor.java:55)


运行结果：DiscardPolicy
[Task{i=}2, Task{i=}3, Task{i=}4, Task{i=}5]
[Task{i=}2, Task{i=}3, Task{i=}4, Task{i=}5]
pool-1-thread-3 task 6
pool-1-thread-2 task 1
pool-1-thread-4 task 7
pool-1-thread-1 task 0

运行结果：DiscardOldestPolicy
[Task{i=}2, Task{i=}3, Task{i=}4, Task{i=}5]
[Task{i=}3, Task{i=}4, Task{i=}5, Task{i=}100]
pool-1-thread-2 task 1
pool-1-thread-4 task 7
pool-1-thread-3 task 6
pool-1-thread-1 task 0

运行结果：CallerRunsPolicy
[Task{i=}2, Task{i=}3, Task{i=}4, Task{i=}5]
pool-1-thread-2 task 1
pool-1-thread-4 task 7
pool-1-thread-1 task 0
main task 100
pool-1-thread-3 task 6

```

## 基于TPE的线程池:SingleThreadPool/CachedThreadPool/FixedThreadPool/ScheduledThreadPool


### ForkJoinFool

![803](643B281504534FC9B50946802D5F89F9) 

    -分解汇总的任务
    -用很少的线程可以执行很多的任务（子任务）TPE做不到先执行子任务
    -CPU密集型

    Fork 任务分叉
    Join 任务汇总

    类似：mapreduce  大规模数据集的并行运算 分布可靠  一种编程模型
    
    ForkJoinTask比较原始
    一般使用：
        RecursiveAction  递归   不带返回值
        RecusiveTask 递归  有返回值
    
    精灵线程？？

#### 笔试题：对100万的随机数进行求和，使用线程池

#### ParallelStreamAPI 

##### 底层使用ForkJoinPool -》 并行流式API -》 流式处理---lambda表达式


```
public class T13_ParallelStreamAPI {
	public static void main(String[] args) {
		List<Integer> nums = new ArrayList<>();
		Random r = new Random();
		for(int i=0; i<10000; i++) nums.add(1000000 + r.nextInt(1000000));
		
		//System.out.println(nums);
		
		long start = System.currentTimeMillis();
		nums.forEach(v->isPrime(v));
		long end = System.currentTimeMillis();
		System.out.println(end - start);
		
		//使用parallel stream api
		
		start = System.currentTimeMillis();
		nums.parallelStream().forEach(T13_ParallelStreamAPI::isPrime);
		end = System.currentTimeMillis();
		
		System.out.println(end - start);
	}
	
	static boolean isPrime(int num) {
		for(int i=2; i<=num/2; i++) {
			if(num % i == 0) return false;
		}
		return true;
	}
}

```


#### ForkJoinPool源码比较复杂，也不考，连老师有课程讲

## ThreadPoolExecutor和ForkJoinPool的区别 -》 ThreadPoolExecutor共用一个任务队列 -》 ForkJoinPool，每个线程有自己的任务队列

# Executors：线程池的工厂

## SingleThreadPool

### 面试题：为什么要有单线程的线程池？-》线程池有任务队列，线程池有完整的生命周期管理，保证任务的顺序

```
源码：
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

```

```
public class T06_SimpleThreadPool {
    public static void main(String[] args) {
        ExecutorService service = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 5; i++) {
            final int j = i;
            service.execute(()->{
                System.out.println(Thread.currentThread().getName()+" "+ j);
            });
        }
        service.shutdown();
    }
}
```

## CachedThreadPool

```
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}

SynchronousQueue为手递手，容量为0的队列

来一个线程，如果线程池中有空闲的线程，则使用；如果没有，则新起一个任务

```


```
public class T07_CachedThreadPool {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService service = Executors.newCachedThreadPool();
        System.out.println(service);
        for (int i = 0; i < 2; i++) {
            service.execute(()->{
                System.out.println(Thread.currentThread().getName());
            });
        }
        System.out.println(service);

        TimeUnit.MILLISECONDS.sleep(100);
        System.out.println(service);

    }
}

运行结果：
  java.util.concurrent.ThreadPoolExecutor@4769b07b[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]
java.util.concurrent.ThreadPoolExecutor@4769b07b[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 0]
pool-1-thread-1
pool-1-thread-2
java.util.concurrent.ThreadPoolExecutor@4769b07b[Running, pool size = 2, active threads = 0, queued tasks = 0, completed tasks = 2]      

```

## FixedThreadPool -》应用：并行处理

    应用：并行处理
    
### 面试题：并发和并行的区别 -》 concurrent：指任务提交；parallel：指任务执行 -》 并行是并发的子集
    
    concurrent：指任务提交
        一个cpu可以并发多个线程
        
    parallel：指任务执行
        多个cpu同时处理
    
    并行是并发的子集
    
    参考书《深入理解计算机系统》
    
    小视频：B站能找到
    
    我的机器是6核12线程
    
### linux操作系统的线程调度策略，按优先级调度，有三种： 实时进程（优先级分高低 - FIFO{First In First Out}，优先级一样 - RRRound{Robin 轮询}）、普通进程(CFS完全公平调度算)

```
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```


```
public class T08_FixedThreadPool {
    static boolean isPrime(int num){
        for (int i = 2; i < num/2; i++) {
            if(num%i == 0) return false;
        }
        return true;
    }

    static List<Integer> getPrimes(int start, int end){
        List<Integer> list = new ArrayList<>();
        for (int i = start; i <=end; i++) {
            if(isPrime(i)) list.add(i);
        }
        return list;
    }

    static class Mytask implements Callable<List<Integer>>{
        int start,end;

        public Mytask(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        public List<Integer> call() throws Exception {
            return getPrimes(start,end);
        }
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        long start,end;
        start = System.currentTimeMillis();
        getPrimes(0,200000);
        end = System.currentTimeMillis();
        System.out.println(end-start);

        final int cpuCoreNum = 4;//CPU的核心线程数为4，我本机是6核12线程
        ExecutorService service = Executors.newFixedThreadPool(cpuCoreNum);
        Mytask task1 = new Mytask(0,50000);
        Mytask task2 = new Mytask(50001,100000);
        Mytask task3 = new Mytask(100001,150000);
        Mytask task4 = new Mytask(150001,200000);

        Future<List<Integer>> f1= service.submit(task1);
        Future<List<Integer>> f2=service.submit(task2);
        Future<List<Integer>> f3=service.submit(task3);
        Future<List<Integer>> f4=service.submit(task4);

        start = System.currentTimeMillis();
        f1.get();
        f2.get();
        f3.get();
        f4.get();
        end = System.currentTimeMillis();
        System.out.println(end-start);
        service.shutdown();
    }
}

运行结果：
1804
796

```

### 调整线程池的大小：Ncpu（cpu的核数） * Ucpu(期望的cpu利用率) * （1+W/C）[等待时间与计算时间的比率]

![801](52FE4BB8D7F147E8B7B029D82136163C)

    多数情况下，根据经验，设置好以后进行压测
    
    这个公式很难计算的，因为W和C的比率是很难确定的
        C中有读取IO的时间，一般count的时间是很短的，几乎为0
        Ucpu也是很难确定的，因为机器上还运行着其他的程序
        
    CPU密集型？
    IO密集型？

#### 这个公式很难计算(Ucpu也是很难确定的，因为机器上还运行着其他的程序;W和C的比率是很难确定的)，多少情况下，根据经验，设置好以后进行压测
    
### Cached VS Fixed -> Cached(任务忽高忽低)/Fixed(来的任务比较平稳) -> 阿里建议两个都不用，自己进行估算以后，进行精确定义

如果任务忽高忽低，建议Cached

如果来的任务比较平稳，采用Fixed

阿里的建议是：两个都不用，自己进行估算以后，进行精确定义

## ScheduledThreadPool定时任务线程池(应用不多,了解就可以) 

```
public class T09_ScheduledThreadPool {
    public static void main(String[] args) {
        ScheduledExecutorService service = Executors.newScheduledThreadPool(4);
        service.scheduleAtFixedRate(()->{
            try {
                TimeUnit.MILLISECONDS.sleep(new Random().nextInt(1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName());
        },0,500, TimeUnit.MILLISECONDS);
    }
}
```

### DelayedWorkQueue -> 应用：定时器框架：quartz、cron

### Executors.newScheduledThreadPool(4) -》 new ScheduledThreadPoolExecutor(corePoolSize) -》 父类ThreadPoolExecutor类

### 最大线程数：Integer.MAX_VALUE

    使用的是：DelayedWorkQueue（*）
    
    定时器框架：
        quartz、cron

    面试题：假如提供了一个闹钟服务，订阅这个服务的人特别多，10亿，怎么优化？
        开放题，暂没有标准答案
        
        1.主服务器把定时任务同步到边缘的机器上
        2.一台机器的优化：使用队列
    
```
Executors类
 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
  
ScheduledThreadPoolExecutor类
public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE,
              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,
              new DelayedWorkQueue());
    }  
    
super-->ThreadPoolExecutor类    
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}    
```

```
代码没看懂
public class T09_ScheduledThreadPool {
    public static void main(String[] args) {
        ScheduledExecutorService service = Executors.newScheduledThreadPool(4);
        service.scheduleAtFixedRate(()->{
            try {
                TimeUnit.MILLISECONDS.sleep(new Random().nextInt(500));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName());
        },0,500, TimeUnit.MILLISECONDS);
    }
}

```

## WorkStealingPool

### 线程池下面有多个线程，每一个线程都有自己单独的队列,当自己的线程队列为空，会到别的workSteallingPool队列的末端去拿任务

### 好处：当某个线程占用很长时间，并且还是特别大的任务，使用WorkStealingPool更加灵活，可以减轻该线程的压力

### 问题：这个线程的队列还有锁吗？push、pop线程的时候不加锁;被别的线程poll的时候，要加锁

### 采用ForkJoinFool

### 问题：既然有ForkjoinFool，为什么还要有WorkStealingPool？-> 没那么复杂，只是提供了一个接口，参数已经定义，方便使用

### 多个work queue + 采用work stealing算法

![802](39A5D010A25546A59A9E2608607B3724)

```
源码
public static ExecutorService newWorkStealingPool() {
    return new ForkJoinPool
        (Runtime.getRuntime().availableProcessors(),
         ForkJoinPool.defaultForkJoinWorkerThreadFactory,
         null, true);
}
```

[TOC]

# ThreadPoolExecutor源码解析

## 1、常用变量的解释

```java
//worker是Runnable，也是AQS

// 1. `ctl`，可以看做一个int类型的数字，高3位表示线程池状态，低29位表示worker数量(线程数量)
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
// 2. `COUNT_BITS`，`Integer.SIZE`为32，所以`COUNT_BITS`为29
private static final int COUNT_BITS = Integer.SIZE - 3;
// 3. `CAPACITY`，线程池允许的最大线程数。1左移29位，然后减1，即为 2^29 - 1
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

// runState is stored in the high-order bits
// 4. 线程池有5种状态，按大小排序如下：RUNNING < SHUTDOWN < STOP < TIDYING < TERMINATED
//STOP--调用shutdownNow()
//TIDYING--线程调用shutdown，线程也执行完了，正在整理的过程
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;

// Packing and unpacking ctl
// 5. `runStateOf()`，获取线程池状态，通过按位与操作，低29位将全部变成0
private static int runStateOf(int c)     { return c & ~CAPACITY; }
// 6. `workerCountOf()`，获取线程池worker数量，通过按位与操作，高3位将全部变成0
private static int workerCountOf(int c)  { return c & CAPACITY; }
// 7. `ctlOf()`，根据线程池状态和线程池worker数量，生成ctl值
private static int ctlOf(int rs, int wc) { return rs | wc; }

/*
 * Bit field accessors that don't require unpacking ctl.
 * These depend on the bit layout and on workerCount being never negative.
 */
// 8. `runStateLessThan()`，线程池状态小于xx
private static boolean runStateLessThan(int c, int s) {
    return c < s;
}
// 9. `runStateAtLeast()`，线程池状态大于等于xx
private static boolean runStateAtLeast(int c, int s) {
    return c >= s;
}
```

## 2、构造方法

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    // 基本类型参数校验
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    // 空指针校验
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    // 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

## 3、提交执行task的过程（重点）

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * Proceed in 3 steps:
     *
     * 1. If fewer than corePoolSize threads are running, try to
     * start a new thread with the given command as its first
     * task.  The call to addWorker atomically checks runState and
     * workerCount, and so prevents false alarms that would add
     * threads when it shouldn't, by returning false.
     *
     * 2. If a task can be successfully queued, then we still need
     * to double-check whether we should have added a thread
     * (because existing ones died since last checking) or that
     * the pool shut down since entry into this method. So we
     * recheck state and if necessary roll back the enqueuing if
     * stopped, or start a new thread if there are none.
     *
     * 3. If we cannot queue task, then we try to add a new
     * thread.  If it fails, we know we are shut down or saturated
     * and so reject the task.
     */
    int c = ctl.get();
    // worker数量比核心线程数小，直接创建worker执行任务
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // worker数量超过核心线程数，任务直接进入队列
    if (isRunning(c) && workQueue.offer(command)) {
        //双重检查
        int recheck = ctl.get();
        // 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作。
        // 这儿为什么需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化。
        if (! isRunning(recheck) && remove(command))
            reject(command);
        // 这儿为什么需要判断0值，主要是在线程池构造方法中，核心线程数允许为0
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务。
    // 这儿有3点需要注意：
    // 1. 线程池不是运行状态时，addWorker内部会判断线程池状态
    // 2. addWorker第2个参数表示是否创建核心线程
    // 3. addWorker返回false，则说明任务执行失败，需要执行reject操作
    else if (!addWorker(command, false))
        reject(command);
}
```

## 4、addworker源码解析（难点）

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    // 外层自旋：本质就是多线程的情况下worker数量加1
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 这个条件写得比较难懂，我对其进行了调整，和下面的条件等价
        // (rs > SHUTDOWN) || 
        // (rs == SHUTDOWN && firstTask != null) || 
        // (rs == SHUTDOWN && workQueue.isEmpty())
        // 1. 线程池状态大于SHUTDOWN时，直接返回false
        // 2. 线程池状态等于SHUTDOWN，且firstTask不为null，直接返回false
        // 3. 线程池状态等于SHUTDOWN，且队列为空，直接返回false
        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        // 内层自旋
        for (;;) {
            int wc = workerCountOf(c);
            // worker数量超过容量，直接返回false
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // 使用CAS的方式增加worker数量。
            // 若增加成功，则直接跳出外层循环进入到第二部分
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            // 线程池状态发生变化，对外层循环进行自旋
            if (runStateOf(c) != rs)
                continue retry;
            // 其他情况，直接内层循环进行自旋即可
            // else CAS failed due to workerCount change; retry inner loop
        } 
    }
    
    //真正加worker
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            // worker的添加必须是串行的，因此需要加锁
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                // 这儿需要重新检查线程池状态
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    // worker已经调用过了start()方法，则不再创建worker
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    // worker创建并添加到workers成功
                    workers.add(w);
                    // 更新`largestPoolSize`变量
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            // 启动worker线程
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        // worker线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown相关操作
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

## 5、线程池worker任务单元

```java

//继承AbstractQueuedSynchronizer，本身就是一个锁，
//当需要执行任务的时候,通过worker.lock()就行
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
{
    /**
     * This class will never be serialized, but we provide a
     * serialVersionUID to suppress a javac warning.
     */
    private static final long serialVersionUID = 6138294804551838833L;

    /** Thread this worker is running in.  Null if factory fails. */
    final Thread thread;
    /** Initial task to run.  Possibly null. */
    Runnable firstTask;
    /** Per-thread task counter */
    volatile long completedTasks;

    /**
     * Creates with given first task and thread from ThreadFactory.
     * @param firstTask the first task (null if none)
     */
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        // 这儿是Worker的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker
        this.thread = getThreadFactory().newThread(this);
    }

    /** Delegates main run loop to outer runWorker  */
    public void run() {
        runWorker(this);
    }

    // 省略代码...
}
```

## 6、核心线程执行逻辑-runworker

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    // 调用unlock()是为了让外部可以中断
    w.unlock(); // allow interrupts
    // 这个变量用于判断是否进入过自旋（while循环）
    boolean completedAbruptly = true;
    try {
        // 这儿是自旋
        // 1. 如果firstTask不为null，则执行firstTask；
        // 2. 如果firstTask为null，则调用getTask()从队列获取任务。
        // 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待
        while (task != null || (task = getTask()) != null) {
            // 这儿对worker进行加锁，是为了达到下面的目的
            // 1. 降低锁范围，提升性能
            // 2. 保证每个worker执行的任务是串行的
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            // 如果线程池正在停止，则对当前线程进行中断操作
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            // 执行任务，且在执行前后通过`beforeExecute()`和`afterExecute()`来扩展其功能。
            // 这两个方法在当前类里面为空实现。
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                // 帮助gc
                task = null;
                // 已完成任务数加一 
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        // 自旋操作被退出，说明线程池正在结束
        processWorkerExit(w, completedAbruptly);
    }
}
```
## 总结：
    
    维护两个集合
        一个线程的集合
        一个任务的集合
    
    底层数据结构：
        HashSet<Worker> workers = new HashSet<>() 
        BlockingQueue<Runnable> workQueue
    
    -----------------
    
    高3位线程池状态，低29位表示worker数量
    
    Worker类:线程池worker任务单元
        继承AQS(锁) + 实现Runnable（可以执行任务，进来的是一个Runnable，需要记录状态） + thread（记录哪个线程执行）
        一个线程(通过线程池工厂添加)+ 一个任务(Runnable，执行=runworker() )+ 已完成的任务数
        
        既是Runnable，也是AQS
        成员变量：thread
        简单理解：worker是一个线程类，里面可以执行  任务
    
    addWorker(相对复杂)：添加worker，并启动
        多线程的情况下worker数量加1：两个死循环(外层自旋+内层自旋)
        内存自选：使用CAS的方式增加worker数量
        
    runworker()
        
        继承AbstractQueuedSynchronizer，本身就是一个锁
        当需要执行任务的时候,通过worker.lock()就行
 
       
    submit方法
    
    execute：执行提交task的过程
        核心线程不够，启核心线程
        核心线程够了，加队列
        队列满了，加非核心线程
    
    
